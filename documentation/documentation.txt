NAMING CONVENTIONS
------------------
* route (i.e. '/products/hacker')
* path (i.e. '/' or 'hacker'): individual route node
* pathArray (i.e. ['products', 'hacker']): array of paths
* schemaObj: initial content objects whose keys only matter (not values)
* typesObj: type of each content field (i.e. matrix, slider, onOff, etc)
* contentUpdateObj: {project, locale, route, content} for transfer from client to server
* oldNewContentPair: [oldContent, [route, newContent]]
* dbBackupObj: an object of mostly meta data inside DB for a changed route (for backup/undo purposes)
* dbContentObj: entry obj in contents table (i.e. {project: 'Project', locale: 'en-US', route: '/', content: {heading: "Home"}})


DATA FLOW
---------
1) Developer flow:
  Client (new partial rootContent from updated schemaObjs (only the pages that have to change))
  -> Server (pass through to DB)
  -> DB (update routes + add dbBackupObj)
2) End user flow:
  Client (pageContent -> [oldVal, newVal (contentUpdateObj)])
  -> Server (pass through to DB)
  -> DB (update route + add dbBackupObj)
3) DB to client flow:
  DB (dbContentObjs)
  -> Server (dbContentObjs -> routeContent/pageContent)
  -> Client (routeContent/pageContent)


DOCUMENTATION
-------------
FOR USER:
1) Set schemaObj (optionally, set typesObj) - waits for projectName & env in localStorage
2) Run getPageContent, getRouteContent, or getRootContent

FOR ME:
1) Wipe out projectName and env from localStorage
2) Get projectName & env from DB and save it to localStorage (then send out 'env:set' event) - if not found, do nothing from here on
3) If env is PREVIEW, load Socket.io-client
4) setPageContentSchema sends events that accumulates (like state$) and sends schema to server/DB when env is ready
5a) if PREVIEW, rootContent arrives asynchronously and routes are updated automatically
5b) if NOT PREVIEW, getPageContent waits for async prop or state

OTHER NOTES
-----------
* Use surge.sh -> i.e. c3-projectHost-preview-prod-com.surge.sh


EXAMPLE DB STRUCTURE
--------------------
const exContentsDBEntry1 = {
  projectDomain: "test.com",
  locale: "en-US",
  route: "$global",
  content: {
    cta: "Free trial"
  }
}
const exContentsDBEntry2 = {
  projectDomain: "test.com",
  locale: "en-US",
  route: "/",
  content: {
    heading: "Home heading"
  }
}
const exContentsDBEntry3 = {
  projectDomain: "test.com",
  locale: "en-US",
  route: "/products/pro",
  content: {
    heading: "Pro heading",
    text: "Pro text"
  }
}

const exBackupsDBEntry = {
  projectDomain: "test.com",
  locale: "en-US",
  changeType: "schema", // "schema" or "content"
  time: 1454170581,
  route: "/products",
  prevContent: {
    heading: "Products heading"
  }
}

const exUsersDBEntry = {
  projectDomain: "test.com",
  email: "email@gmail.com",
  firstName: "Sam",
  lastName: "Smith",
  accessLevel: "superadmin"
}

const exProjectsDBEntry = {
  name: "Project Name",
  prodDomain: "blah.com",
  stagingDomain: "staging.blah.com",
  previewProdDomain: "preview.blah.com",
  previewStagingDomain: "preview.blah.com",
  users: ["blah@gmail.com", "blahblah@gmail.com"],
  defaultLocale: "en-US",
  locales: ["en-US", "fr-FR"],
  domainMap: {
    "com": "en-US"
  }
}

const exMetadataDBEntry = {
  projectDomain: "test.com",
  userEmail: "email@gmail.com",
  recentlyViewedRoutes: [
    "1",
    "2"
  ],
  newlyAddedRoutes: [
    "1",
    "2"
  ]
}
