NAMING CONVENTIONS
------------------
* route (i.e. '/products/hacker')
* path (i.e. '/' or 'hacker'): individual route node
* pathArray (i.e. ['products', 'hacker']): array of paths
* schemaObj: initial content objects whose keys only matter (not values)
* typesObj: type of each content field (i.e. matrix, slider, onOff, etc)
* contentRequestObj: {projectDomain, env, locale, route} for getting content
* contentUpdateObj: {projectDomain, env, locale, route, content} for updating content
* oldNewContentPair: [oldContent, [route, newContent]]
* dbBackupObj: an object of mostly meta data inside DB for a changed route (for backup/undo purposes)
* dbContentObj: entry obj in contents table (i.e. {project: 'Project', locale: 'en-US', route: '/', content: {heading: "Home"}})
* contentInitObj: {projectDetails, env, isPreview, requestRouteContent} sent from the server on initial content request (for the client)


DATA FLOW
---------
1) Developer flow:
  Client (new partial rootContent from updated schemaObjs (only the pages that have to change))
  -> Server (pass through to DB)
  -> DB (update routes + add dbBackupObj)
2) End user flow:
  Client (pageContent -> [oldVal, newVal (contentUpdateObj)])
  -> Server (pass through to DB)
  -> DB (update route + add dbBackupObj)
3) DB to client flow:
  DB (dbContentObjs)
  -> Server (dbContentObjs -> routeContent/pageContent)
  -> Client (routeContent/pageContent)


CLIENT-SIDE DOCUMENTATION
-------------------------
FOR USER:
1) On entry file, call getRootContent(projectDomain, route, [excluded routes]) - returns on observable
   NOTE: projectDomain here is not technically required, but added for optimized DB query with secondary index rather than a lot of filtering since performance here is critical
2) Set schemaObj (optionally, set typesObj) - waits for rootContent & projectDetails in localStorage
3) Run getContent()

FOR ME:
0) Provide a placeholder for content until the content arrives and populates
1) First on app load, get current domain and run getRootContent()
   -> get projectDetails (using domain, env, locale) and rootContent from DB
1a) If current domain is local, use the schemaObj locally (but check localStorage first for rootContent - from the last iteration)
2) When routeContent & projectDetails arrive, save projectDetails, env, isPreview in localStorage and return routeContent
3) Compare the setContentSchema with rootContent in localStorage and if different:
  1) Send out the new contentUpdateObj
  2) Update the rootContent in localStorage with the new contentUpdateObj
  3) Have page just use rootContent as usual
  4) Make sure to put setContentSchema above getPageCont

+) If PREVIEW (i.e. current domain matches one of the preview domains):
  1) POST call and if PREVIEW, set PREVIEW=true in localStorage
  2) load socket.io client
  3) Instead of doing a GET for getRootContent(), emit a socket.io event and receive it too
  4) Receive field update events and update the content real-time
  5) Use mutation observer to highlight the part that's being edited
+) If local (i.e. localhost:port):
  1) Do nothing for getRootContent()
  2) setContentSchema should save itself in localStorage (for getContent)
  3) getContent should grab content from localStorage


OTHER NOTES
-----------
* Use surge.sh -> i.e. c3-projectHost-preview-prod-com.surge.sh


EXAMPLE DB STRUCTURE
--------------------
const exContentsDBEntry1 = {
  projectDomain: "test.com",
  route: "$global",
  content: {
    cta: "Free trial"
  }
}
const exContentsDBEntry2 = {
  projectDomain: "test.com",
  route: "/",
  content: {
    heading: "Home heading"
  }
}
const exContentsDBEntry3 = {
  projectDomain: "test.com",
  route: "/products/pro",
  content: {
    heading: "Pro heading",
    text: "Pro text"
  }
}

const exBackupsDBEntry = {
  projectDomain: "test.com",
  changeType: "schema", // "schema" or "content"
  time: 1454170581,
  route: "/products",
  prevContent: {
    heading: "Products heading"
  }
}

const exUsersDBEntry = {
  projectDomain: "test.com",
  email: "email@gmail.com",
  firstName: "Sam",
  lastName: "Smith",
  accessLevel: "superadmin"
}

const exProjectsDBEntry = {
  name: "Project Name",
  projectDomain: "blah.com", // this is the identifier (including subdomain)
  localDomains: ["127.0.0.1"],
  prodDomains: ["blah.com", "blah.fr"],
  stagingDomains: ["staging.blah.com", "staging.blah.fr"],
  previewProdDomains: ["preview.blah.com"],
  previewStagingDomains: ["preview.staging.blah.com"],
  users: {
    superadmin: ['blah@blah.com'],
    admin: ['blah@blah.com'],
    readonly: ['blah@blah.com']
  },
  defaultLocale: "en-US",
  localeMap: {
    "en-US": {
      prodDomain: "blah.com",
      stagingDomain: "staging.blah.com",
      previewProdDomain: "preview.blah.com",
      previewStagingDomain: "preview.staging.blah.com"
    },
    "fr-FR": {
      prodDomain: "blah.fr"
    }
  }
}

const exMetadataDBEntry = {
  projectDomain: "test.com",
  userEmail: "email@gmail.com",
  recentlyViewedRoutes: [
    "1",
    "2"
  ],
  newlyAddedRoutes: [
    "1",
    "2"
  ]
}
